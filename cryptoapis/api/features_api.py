# coding: utf-8

"""
    CryptoAPIs

    Crypto APIs is a complex and innovative infrastructure layer that radically simplifies the development of any Blockchain and Crypto related applications. Organized around REST, Crypto APIs can assist both novice Bitcoin/Ethereum enthusiasts and crypto experts with the development of their blockchain applications. Crypto APIs provides unified endpoints and data, raw data, automatic tokens and coins forwardings, callback functionalities, and much more.  # noqa: E501

    The version of the OpenAPI document: 2021-03-20
    Contact: developers@cryptoapis.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr

from typing import Optional

from cryptoapis.models.broadcast_locally_signed_transaction_r import BroadcastLocallySignedTransactionR
from cryptoapis.models.broadcast_locally_signed_transaction_rb import BroadcastLocallySignedTransactionRB
from cryptoapis.models.convert_bitcoin_cash_address_r import ConvertBitcoinCashAddressR
from cryptoapis.models.convert_bitcoin_cash_address_rb import ConvertBitcoinCashAddressRB
from cryptoapis.models.decode_raw_transaction_hex_r import DecodeRawTransactionHexR
from cryptoapis.models.decode_raw_transaction_hex_rb import DecodeRawTransactionHexRB
from cryptoapis.models.decode_x_address_r import DecodeXAddressR
from cryptoapis.models.derive_hd_wallet_x_pub_y_pub_z_pub_change_or_receiving_addresses_r import DeriveHDWalletXPubYPubZPubChangeOrReceivingAddressesR
from cryptoapis.models.encode_x_address_r import EncodeXAddressR
from cryptoapis.models.estimate_gas_limit_r import EstimateGasLimitR
from cryptoapis.models.estimate_gas_limit_rb import EstimateGasLimitRB
from cryptoapis.models.estimate_token_gas_limit_r import EstimateTokenGasLimitR
from cryptoapis.models.estimate_token_gas_limit_rb import EstimateTokenGasLimitRB
from cryptoapis.models.get_eip1559_fee_recommendations_r import GetEIP1559FeeRecommendationsR
from cryptoapis.models.prepare_a_fungible_token_transfer_from_address_r import PrepareAFungibleTokenTransferFromAddressR
from cryptoapis.models.prepare_a_fungible_token_transfer_from_address_rb import PrepareAFungibleTokenTransferFromAddressRB
from cryptoapis.models.prepare_a_non_fungible_token_transfer_from_address_r import PrepareANonFungibleTokenTransferFromAddressR
from cryptoapis.models.prepare_a_non_fungible_token_transfer_from_address_rb import PrepareANonFungibleTokenTransferFromAddressRB
from cryptoapis.models.prepare_transaction_from_address_r import PrepareTransactionFromAddressR
from cryptoapis.models.prepare_transaction_from_address_rb import PrepareTransactionFromAddressRB
from cryptoapis.models.validate_address_r import ValidateAddressR
from cryptoapis.models.validate_address_rb import ValidateAddressRB

from cryptoapis.api_client import ApiClient
from cryptoapis.api_response import ApiResponse
from cryptoapis.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class FeaturesApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def broadcast_locally_signed_transaction(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, broadcast_locally_signed_transaction_rb : Optional[BroadcastLocallySignedTransactionRB] = None, **kwargs) -> BroadcastLocallySignedTransactionR:  # noqa: E501
        """Broadcast Locally Signed Transaction  # noqa: E501

        Through this endpoint customers can broadcast transactions that have been already signed locally. Instead of using a node for broadcasting a signed transaction users can use this endpoint. We then keep the user posted about the status by sending you a callback with a success or failure status.    {warning}This can be prepared and signed **only** locally, not through the API. We can provide support only for the process of broadcasting.{/warning}  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.broadcast_locally_signed_transaction(blockchain, network, context, broadcast_locally_signed_transaction_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param broadcast_locally_signed_transaction_rb:
        :type broadcast_locally_signed_transaction_rb: BroadcastLocallySignedTransactionRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BroadcastLocallySignedTransactionR
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the broadcast_locally_signed_transaction_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.broadcast_locally_signed_transaction_with_http_info(blockchain, network, context, broadcast_locally_signed_transaction_rb, **kwargs)  # noqa: E501

    @validate_arguments
    def broadcast_locally_signed_transaction_with_http_info(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, broadcast_locally_signed_transaction_rb : Optional[BroadcastLocallySignedTransactionRB] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Broadcast Locally Signed Transaction  # noqa: E501

        Through this endpoint customers can broadcast transactions that have been already signed locally. Instead of using a node for broadcasting a signed transaction users can use this endpoint. We then keep the user posted about the status by sending you a callback with a success or failure status.    {warning}This can be prepared and signed **only** locally, not through the API. We can provide support only for the process of broadcasting.{/warning}  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.broadcast_locally_signed_transaction_with_http_info(blockchain, network, context, broadcast_locally_signed_transaction_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param broadcast_locally_signed_transaction_rb:
        :type broadcast_locally_signed_transaction_rb: BroadcastLocallySignedTransactionRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BroadcastLocallySignedTransactionR, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'blockchain',
            'network',
            'context',
            'broadcast_locally_signed_transaction_rb'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method broadcast_locally_signed_transaction" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['blockchain']:
            _path_params['blockchain'] = _params['blockchain']

        if _params['network']:
            _path_params['network'] = _params['network']


        # process the query parameters
        _query_params = []
        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['broadcast_locally_signed_transaction_rb'] is not None:
            _body_params = _params['broadcast_locally_signed_transaction_rb']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "BroadcastLocallySignedTransactionR",
            '400': "object",
            '401': "object",
            '402': "object",
            '403': "object",
            '404': "object",
            '409': "object",
            '415': "object",
            '422': "object",
            '429': "object",
            '500': "object",
        }

        return self.api_client.call_api(
            '/blockchain-tools/{blockchain}/{network}/transactions/broadcast', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def convert_bitcoin_cash_address(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, convert_bitcoin_cash_address_rb : Optional[ConvertBitcoinCashAddressRB] = None, **kwargs) -> ConvertBitcoinCashAddressR:  # noqa: E501
        """Convert Bitcoin Cash Address  # noqa: E501

        Through this endpoint customers will be able to convert addresses for the BCH (Bitcoin Cash) protocol from BCH legacy to cash address and vice versa.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.convert_bitcoin_cash_address(blockchain, network, context, convert_bitcoin_cash_address_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param convert_bitcoin_cash_address_rb:
        :type convert_bitcoin_cash_address_rb: ConvertBitcoinCashAddressRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ConvertBitcoinCashAddressR
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the convert_bitcoin_cash_address_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.convert_bitcoin_cash_address_with_http_info(blockchain, network, context, convert_bitcoin_cash_address_rb, **kwargs)  # noqa: E501

    @validate_arguments
    def convert_bitcoin_cash_address_with_http_info(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, convert_bitcoin_cash_address_rb : Optional[ConvertBitcoinCashAddressRB] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Convert Bitcoin Cash Address  # noqa: E501

        Through this endpoint customers will be able to convert addresses for the BCH (Bitcoin Cash) protocol from BCH legacy to cash address and vice versa.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.convert_bitcoin_cash_address_with_http_info(blockchain, network, context, convert_bitcoin_cash_address_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param convert_bitcoin_cash_address_rb:
        :type convert_bitcoin_cash_address_rb: ConvertBitcoinCashAddressRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ConvertBitcoinCashAddressR, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'blockchain',
            'network',
            'context',
            'convert_bitcoin_cash_address_rb'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method convert_bitcoin_cash_address" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['blockchain']:
            _path_params['blockchain'] = _params['blockchain']

        if _params['network']:
            _path_params['network'] = _params['network']


        # process the query parameters
        _query_params = []
        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['convert_bitcoin_cash_address_rb'] is not None:
            _body_params = _params['convert_bitcoin_cash_address_rb']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '201': "ConvertBitcoinCashAddressR",
            '400': "ConvertBitcoinCashAddress400Response",
            '401': "ConvertBitcoinCashAddress401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "ConvertBitcoinCashAddress403Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }

        return self.api_client.call_api(
            '/blockchain-tools/{blockchain}/{network}/address/convert', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def decode_raw_transaction_hex(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, decode_raw_transaction_hex_rb : Optional[DecodeRawTransactionHexRB] = None, **kwargs) -> DecodeRawTransactionHexR:  # noqa: E501
        """Decode Raw Transaction Hex  # noqa: E501

        Through this endpoint customers can decode a raw transaction hex and see the decoded transactions' details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.decode_raw_transaction_hex(blockchain, network, context, decode_raw_transaction_hex_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param decode_raw_transaction_hex_rb:
        :type decode_raw_transaction_hex_rb: DecodeRawTransactionHexRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DecodeRawTransactionHexR
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the decode_raw_transaction_hex_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.decode_raw_transaction_hex_with_http_info(blockchain, network, context, decode_raw_transaction_hex_rb, **kwargs)  # noqa: E501

    @validate_arguments
    def decode_raw_transaction_hex_with_http_info(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, decode_raw_transaction_hex_rb : Optional[DecodeRawTransactionHexRB] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Decode Raw Transaction Hex  # noqa: E501

        Through this endpoint customers can decode a raw transaction hex and see the decoded transactions' details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.decode_raw_transaction_hex_with_http_info(blockchain, network, context, decode_raw_transaction_hex_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param decode_raw_transaction_hex_rb:
        :type decode_raw_transaction_hex_rb: DecodeRawTransactionHexRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DecodeRawTransactionHexR, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'blockchain',
            'network',
            'context',
            'decode_raw_transaction_hex_rb'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method decode_raw_transaction_hex" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['blockchain']:
            _path_params['blockchain'] = _params['blockchain']

        if _params['network']:
            _path_params['network'] = _params['network']


        # process the query parameters
        _query_params = []
        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['decode_raw_transaction_hex_rb'] is not None:
            _body_params = _params['decode_raw_transaction_hex_rb']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "DecodeRawTransactionHexR",
            '400': "DecodeRawTransactionHex400Response",
            '401': "DecodeRawTransactionHex401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "DecodeRawTransactionHex403Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }

        return self.api_client.call_api(
            '/blockchain-tools/{blockchain}/{network}/decode-raw-transaction', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def decode_x_address(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], x_address : Annotated[StrictStr, Field(..., description="Represents the encoded classic address with its destination tag.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, **kwargs) -> DecodeXAddressR:  # noqa: E501
        """Decode X-Address  # noqa: E501

        Through this endpoint, customers can decode an encoded XRP address with tag, by providing the specific x-address. The response includes the decoded classic address and the tag.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.decode_x_address(blockchain, network, x_address, context, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param x_address: Represents the encoded classic address with its destination tag. (required)
        :type x_address: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DecodeXAddressR
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the decode_x_address_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.decode_x_address_with_http_info(blockchain, network, x_address, context, **kwargs)  # noqa: E501

    @validate_arguments
    def decode_x_address_with_http_info(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], x_address : Annotated[StrictStr, Field(..., description="Represents the encoded classic address with its destination tag.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Decode X-Address  # noqa: E501

        Through this endpoint, customers can decode an encoded XRP address with tag, by providing the specific x-address. The response includes the decoded classic address and the tag.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.decode_x_address_with_http_info(blockchain, network, x_address, context, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param x_address: Represents the encoded classic address with its destination tag. (required)
        :type x_address: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DecodeXAddressR, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'blockchain',
            'network',
            'x_address',
            'context'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method decode_x_address" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['blockchain']:
            _path_params['blockchain'] = _params['blockchain']

        if _params['network']:
            _path_params['network'] = _params['network']

        if _params['x_address']:
            _path_params['xAddress'] = _params['x_address']


        # process the query parameters
        _query_params = []
        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "DecodeXAddressR",
            '400': "DecodeXAddress400Response",
            '401': "DecodeXAddress401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "DecodeXAddress403Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }

        return self.api_client.call_api(
            '/blockchain-tools/{blockchain}/{network}/decode-x-address/{xAddress}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def derive_hd_wallet__x_pub_y_pub_z_pub_change_or_receiving_addresses(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], extended_public_key : Annotated[StrictStr, Field(..., description="Defines the account extended publicly known key which is used to derive all child public keys.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, address_format : Annotated[Optional[StrictStr], Field(description="Represents the format of the address.")] = None, addresses_count : Annotated[Optional[StrictInt], Field(description="Represents the addresses count.")] = None, is_change : Annotated[Optional[StrictBool], Field(description="Defines if the specific address is a change or deposit address. If the value is True - it is a change address, if it is False - it is a Deposit address.")] = None, start_index : Annotated[Optional[StrictInt], Field(description="The starting index of the response items, i.e. where the response should start listing the returned items.")] = None, **kwargs) -> DeriveHDWalletXPubYPubZPubChangeOrReceivingAddressesR:  # noqa: E501
        """Derive HD Wallet (xPub, yPub, zPub) Change Or Receiving Addresses  # noqa: E501

        Through this endpoint, customers can derive up to 10 addresses - both change and receive, from a certain HD Wallet (xPub, yPub, zPub), by providing an extended public key. By default the system creates a receiving/deposit address, unless the isChange attribute is set to 'true'. In that case the system derives a 'change' address. The change address can be derived only for UTXO based blockchains, for all the rest, this endpoint always creates a deposit/receiving address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.derive_hd_wallet__x_pub_y_pub_z_pub_change_or_receiving_addresses(blockchain, extended_public_key, network, context, address_format, addresses_count, is_change, start_index, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param extended_public_key: Defines the account extended publicly known key which is used to derive all child public keys. (required)
        :type extended_public_key: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param address_format: Represents the format of the address.
        :type address_format: str
        :param addresses_count: Represents the addresses count.
        :type addresses_count: int
        :param is_change: Defines if the specific address is a change or deposit address. If the value is True - it is a change address, if it is False - it is a Deposit address.
        :type is_change: bool
        :param start_index: The starting index of the response items, i.e. where the response should start listing the returned items.
        :type start_index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeriveHDWalletXPubYPubZPubChangeOrReceivingAddressesR
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the derive_hd_wallet__x_pub_y_pub_z_pub_change_or_receiving_addresses_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.derive_hd_wallet__x_pub_y_pub_z_pub_change_or_receiving_addresses_with_http_info(blockchain, extended_public_key, network, context, address_format, addresses_count, is_change, start_index, **kwargs)  # noqa: E501

    @validate_arguments
    def derive_hd_wallet__x_pub_y_pub_z_pub_change_or_receiving_addresses_with_http_info(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], extended_public_key : Annotated[StrictStr, Field(..., description="Defines the account extended publicly known key which is used to derive all child public keys.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, address_format : Annotated[Optional[StrictStr], Field(description="Represents the format of the address.")] = None, addresses_count : Annotated[Optional[StrictInt], Field(description="Represents the addresses count.")] = None, is_change : Annotated[Optional[StrictBool], Field(description="Defines if the specific address is a change or deposit address. If the value is True - it is a change address, if it is False - it is a Deposit address.")] = None, start_index : Annotated[Optional[StrictInt], Field(description="The starting index of the response items, i.e. where the response should start listing the returned items.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Derive HD Wallet (xPub, yPub, zPub) Change Or Receiving Addresses  # noqa: E501

        Through this endpoint, customers can derive up to 10 addresses - both change and receive, from a certain HD Wallet (xPub, yPub, zPub), by providing an extended public key. By default the system creates a receiving/deposit address, unless the isChange attribute is set to 'true'. In that case the system derives a 'change' address. The change address can be derived only for UTXO based blockchains, for all the rest, this endpoint always creates a deposit/receiving address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.derive_hd_wallet__x_pub_y_pub_z_pub_change_or_receiving_addresses_with_http_info(blockchain, extended_public_key, network, context, address_format, addresses_count, is_change, start_index, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param extended_public_key: Defines the account extended publicly known key which is used to derive all child public keys. (required)
        :type extended_public_key: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param address_format: Represents the format of the address.
        :type address_format: str
        :param addresses_count: Represents the addresses count.
        :type addresses_count: int
        :param is_change: Defines if the specific address is a change or deposit address. If the value is True - it is a change address, if it is False - it is a Deposit address.
        :type is_change: bool
        :param start_index: The starting index of the response items, i.e. where the response should start listing the returned items.
        :type start_index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeriveHDWalletXPubYPubZPubChangeOrReceivingAddressesR, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'blockchain',
            'extended_public_key',
            'network',
            'context',
            'address_format',
            'addresses_count',
            'is_change',
            'start_index'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method derive_hd_wallet__x_pub_y_pub_z_pub_change_or_receiving_addresses" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['blockchain']:
            _path_params['blockchain'] = _params['blockchain']

        if _params['extended_public_key']:
            _path_params['extendedPublicKey'] = _params['extended_public_key']

        if _params['network']:
            _path_params['network'] = _params['network']


        # process the query parameters
        _query_params = []
        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        if _params.get('address_format') is not None:  # noqa: E501
            _query_params.append(('addressFormat', _params['address_format'].value))

        if _params.get('addresses_count') is not None:  # noqa: E501
            _query_params.append(('addressesCount', _params['addresses_count']))

        if _params.get('is_change') is not None:  # noqa: E501
            _query_params.append(('isChange', _params['is_change']))

        if _params.get('start_index') is not None:  # noqa: E501
            _query_params.append(('startIndex', _params['start_index']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "DeriveHDWalletXPubYPubZPubChangeOrReceivingAddressesR",
            '400': "DeriveHDWalletXPubYPubZPubChangeOrReceivingAddresses400Response",
            '401': "DeriveHDWalletXPubYPubZPubChangeOrReceivingAddresses401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "DeriveHDWalletXPubYPubZPubChangeOrReceivingAddresses403Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }

        return self.api_client.call_api(
            '/blockchain-tools/{blockchain}/{network}/hd/{extendedPublicKey}/addresses/derive-address', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def encode_x_address(self, address_tag : Annotated[StrictInt, Field(..., description="Defines a specific Tag that is an additional XRP address feature. It helps identifying a transaction recipient beyond a wallet address.")], blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], classic_address : Annotated[StrictStr, Field(..., description="Represents the public address, which is a compressed and shortened form of a public key.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, **kwargs) -> EncodeXAddressR:  # noqa: E501
        """Encode X-Address  # noqa: E501

        Through this endpoint, customers can encode an encoded XRP address with tag, by providing the specific x-address. The response includes the encoded classic address and the tag.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.encode_x_address(address_tag, blockchain, classic_address, network, context, async_req=True)
        >>> result = thread.get()

        :param address_tag: Defines a specific Tag that is an additional XRP address feature. It helps identifying a transaction recipient beyond a wallet address. (required)
        :type address_tag: int
        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param classic_address: Represents the public address, which is a compressed and shortened form of a public key. (required)
        :type classic_address: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EncodeXAddressR
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the encode_x_address_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.encode_x_address_with_http_info(address_tag, blockchain, classic_address, network, context, **kwargs)  # noqa: E501

    @validate_arguments
    def encode_x_address_with_http_info(self, address_tag : Annotated[StrictInt, Field(..., description="Defines a specific Tag that is an additional XRP address feature. It helps identifying a transaction recipient beyond a wallet address.")], blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], classic_address : Annotated[StrictStr, Field(..., description="Represents the public address, which is a compressed and shortened form of a public key.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Encode X-Address  # noqa: E501

        Through this endpoint, customers can encode an encoded XRP address with tag, by providing the specific x-address. The response includes the encoded classic address and the tag.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.encode_x_address_with_http_info(address_tag, blockchain, classic_address, network, context, async_req=True)
        >>> result = thread.get()

        :param address_tag: Defines a specific Tag that is an additional XRP address feature. It helps identifying a transaction recipient beyond a wallet address. (required)
        :type address_tag: int
        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param classic_address: Represents the public address, which is a compressed and shortened form of a public key. (required)
        :type classic_address: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EncodeXAddressR, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'address_tag',
            'blockchain',
            'classic_address',
            'network',
            'context'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method encode_x_address" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['address_tag']:
            _path_params['addressTag'] = _params['address_tag']

        if _params['blockchain']:
            _path_params['blockchain'] = _params['blockchain']

        if _params['classic_address']:
            _path_params['classicAddress'] = _params['classic_address']

        if _params['network']:
            _path_params['network'] = _params['network']


        # process the query parameters
        _query_params = []
        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "EncodeXAddressR",
            '400': "EncodeXAddress400Response",
            '401': "EncodeXAddress401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "EncodeXAddress403Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }

        return self.api_client.call_api(
            '/blockchain-tools/{blockchain}/{network}/encode-x-address/{classicAddress}/{addressTag}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def estimate_gas_limit(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, estimate_gas_limit_rb : Optional[EstimateGasLimitRB] = None, **kwargs) -> EstimateGasLimitR:  # noqa: E501
        """Estimate Gas Limit  # noqa: E501

        This endpoint helps customer in estimating the gas limit needed for a transaction. It gives information for gas expenses when sending ether to contracts or making a transaction with additional data in it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.estimate_gas_limit(blockchain, network, context, estimate_gas_limit_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param estimate_gas_limit_rb:
        :type estimate_gas_limit_rb: EstimateGasLimitRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EstimateGasLimitR
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the estimate_gas_limit_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.estimate_gas_limit_with_http_info(blockchain, network, context, estimate_gas_limit_rb, **kwargs)  # noqa: E501

    @validate_arguments
    def estimate_gas_limit_with_http_info(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, estimate_gas_limit_rb : Optional[EstimateGasLimitRB] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Estimate Gas Limit  # noqa: E501

        This endpoint helps customer in estimating the gas limit needed for a transaction. It gives information for gas expenses when sending ether to contracts or making a transaction with additional data in it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.estimate_gas_limit_with_http_info(blockchain, network, context, estimate_gas_limit_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param estimate_gas_limit_rb:
        :type estimate_gas_limit_rb: EstimateGasLimitRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EstimateGasLimitR, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'blockchain',
            'network',
            'context',
            'estimate_gas_limit_rb'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method estimate_gas_limit" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['blockchain']:
            _path_params['blockchain'] = _params['blockchain']

        if _params['network']:
            _path_params['network'] = _params['network']


        # process the query parameters
        _query_params = []
        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['estimate_gas_limit_rb'] is not None:
            _body_params = _params['estimate_gas_limit_rb']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "EstimateGasLimitR",
            '400': "EstimateGasLimit400Response",
            '401': "EstimateGasLimit401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "EstimateGasLimit403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }

        return self.api_client.call_api(
            '/blockchain-tools/{blockchain}/{network}/gas-limit', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def estimate_token_gas_limit(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, estimate_token_gas_limit_rb : Optional[EstimateTokenGasLimitRB] = None, **kwargs) -> EstimateTokenGasLimitR:  # noqa: E501
        """Estimate Token Gas Limit  # noqa: E501

        This endpoint helps customer in estimating the Contract Gas Limit needed for a transaction. It gives information for gas expenses for a specific contract when sending ethers or making a transaction with additional data in it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.estimate_token_gas_limit(blockchain, network, context, estimate_token_gas_limit_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param estimate_token_gas_limit_rb:
        :type estimate_token_gas_limit_rb: EstimateTokenGasLimitRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: EstimateTokenGasLimitR
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the estimate_token_gas_limit_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.estimate_token_gas_limit_with_http_info(blockchain, network, context, estimate_token_gas_limit_rb, **kwargs)  # noqa: E501

    @validate_arguments
    def estimate_token_gas_limit_with_http_info(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, estimate_token_gas_limit_rb : Optional[EstimateTokenGasLimitRB] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Estimate Token Gas Limit  # noqa: E501

        This endpoint helps customer in estimating the Contract Gas Limit needed for a transaction. It gives information for gas expenses for a specific contract when sending ethers or making a transaction with additional data in it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.estimate_token_gas_limit_with_http_info(blockchain, network, context, estimate_token_gas_limit_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param estimate_token_gas_limit_rb:
        :type estimate_token_gas_limit_rb: EstimateTokenGasLimitRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(EstimateTokenGasLimitR, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'blockchain',
            'network',
            'context',
            'estimate_token_gas_limit_rb'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method estimate_token_gas_limit" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['blockchain']:
            _path_params['blockchain'] = _params['blockchain']

        if _params['network']:
            _path_params['network'] = _params['network']


        # process the query parameters
        _query_params = []
        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['estimate_token_gas_limit_rb'] is not None:
            _body_params = _params['estimate_token_gas_limit_rb']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "EstimateTokenGasLimitR",
            '400': "EstimateTokenGasLimit400Response",
            '401': "EstimateTokenGasLimit401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "EstimateTokenGasLimit403Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }

        return self.api_client.call_api(
            '/blockchain-tools/{blockchain}/{network}/gas-limit/contract', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_eip_1559_fee_recommendations(self, network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, **kwargs) -> GetEIP1559FeeRecommendationsR:  # noqa: E501
        """Get EIP 1559 Fee Recommendations  # noqa: E501

        Through this endpoint customers can obtain fee recommendations specifically for EIP 1559.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_eip_1559_fee_recommendations(network, blockchain, context, async_req=True)
        >>> result = thread.get()

        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum. (required)
        :type blockchain: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetEIP1559FeeRecommendationsR
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_eip_1559_fee_recommendations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_eip_1559_fee_recommendations_with_http_info(network, blockchain, context, **kwargs)  # noqa: E501

    @validate_arguments
    def get_eip_1559_fee_recommendations_with_http_info(self, network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get EIP 1559 Fee Recommendations  # noqa: E501

        Through this endpoint customers can obtain fee recommendations specifically for EIP 1559.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_eip_1559_fee_recommendations_with_http_info(network, blockchain, context, async_req=True)
        >>> result = thread.get()

        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum. (required)
        :type blockchain: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetEIP1559FeeRecommendationsR, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'network',
            'blockchain',
            'context'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_eip_1559_fee_recommendations" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['network']:
            _path_params['network'] = _params['network']

        if _params['blockchain']:
            _path_params['blockchain'] = _params['blockchain']


        # process the query parameters
        _query_params = []
        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "GetEIP1559FeeRecommendationsR",
            '400': "GetEIP1559FeeRecommendations400Response",
            '401': "GetEIP1559FeeRecommendations401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "GetEIP1559FeeRecommendations403Response",
            '404': "GetXRPRippleTransactionDetailsByTransactionID404Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }

        return self.api_client.call_api(
            '/blockchain-tools/{blockchain}/{network}/fees/eip1559', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def prepare_a_fungible_token_transfer_from_address(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"mordor\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, prepare_a_fungible_token_transfer_from_address_rb : Optional[PrepareAFungibleTokenTransferFromAddressRB] = None, **kwargs) -> PrepareAFungibleTokenTransferFromAddressR:  # noqa: E501
        """Prepare A Fungible Token Transfer From Address  # noqa: E501

        Using this endpoint customers can prepare a fungible token transfer from an address with private and public keys. The address doesn’t have to belong to a wallet. The response will include the transaction fee in Wei.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.prepare_a_fungible_token_transfer_from_address(blockchain, network, context, prepare_a_fungible_token_transfer_from_address_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"mordor\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param prepare_a_fungible_token_transfer_from_address_rb:
        :type prepare_a_fungible_token_transfer_from_address_rb: PrepareAFungibleTokenTransferFromAddressRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PrepareAFungibleTokenTransferFromAddressR
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the prepare_a_fungible_token_transfer_from_address_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.prepare_a_fungible_token_transfer_from_address_with_http_info(blockchain, network, context, prepare_a_fungible_token_transfer_from_address_rb, **kwargs)  # noqa: E501

    @validate_arguments
    def prepare_a_fungible_token_transfer_from_address_with_http_info(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"mordor\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, prepare_a_fungible_token_transfer_from_address_rb : Optional[PrepareAFungibleTokenTransferFromAddressRB] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Prepare A Fungible Token Transfer From Address  # noqa: E501

        Using this endpoint customers can prepare a fungible token transfer from an address with private and public keys. The address doesn’t have to belong to a wallet. The response will include the transaction fee in Wei.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.prepare_a_fungible_token_transfer_from_address_with_http_info(blockchain, network, context, prepare_a_fungible_token_transfer_from_address_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"mordor\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param prepare_a_fungible_token_transfer_from_address_rb:
        :type prepare_a_fungible_token_transfer_from_address_rb: PrepareAFungibleTokenTransferFromAddressRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PrepareAFungibleTokenTransferFromAddressR, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'blockchain',
            'network',
            'context',
            'prepare_a_fungible_token_transfer_from_address_rb'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method prepare_a_fungible_token_transfer_from_address" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['blockchain']:
            _path_params['blockchain'] = _params['blockchain']

        if _params['network']:
            _path_params['network'] = _params['network']


        # process the query parameters
        _query_params = []
        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['prepare_a_fungible_token_transfer_from_address_rb'] is not None:
            _body_params = _params['prepare_a_fungible_token_transfer_from_address_rb']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '201': "PrepareAFungibleTokenTransferFromAddressR",
            '400': "PrepareAFungibleTokenTransferFromAddress400Response",
            '401': "PrepareAFungibleTokenTransferFromAddress401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "PrepareAFungibleTokenTransferFromAddress403Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }

        return self.api_client.call_api(
            '/blockchain-tools/{blockchain}/{network}/transactions/prepare-token-from-address', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def prepare_a_non_fungible_token_transfer_from_address(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"mordor\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, prepare_a_non_fungible_token_transfer_from_address_rb : Optional[PrepareANonFungibleTokenTransferFromAddressRB] = None, **kwargs) -> PrepareANonFungibleTokenTransferFromAddressR:  # noqa: E501
        """Prepare A Non Fungible Token Transfer From Address  # noqa: E501

        Using this endpoint customers can prepare a non-fungible token transfer from an address with private and public keys. The address doesn’t have to belong to a wallet. The response will include the transaction fee in Wei.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.prepare_a_non_fungible_token_transfer_from_address(blockchain, network, context, prepare_a_non_fungible_token_transfer_from_address_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"mordor\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param prepare_a_non_fungible_token_transfer_from_address_rb:
        :type prepare_a_non_fungible_token_transfer_from_address_rb: PrepareANonFungibleTokenTransferFromAddressRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PrepareANonFungibleTokenTransferFromAddressR
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the prepare_a_non_fungible_token_transfer_from_address_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.prepare_a_non_fungible_token_transfer_from_address_with_http_info(blockchain, network, context, prepare_a_non_fungible_token_transfer_from_address_rb, **kwargs)  # noqa: E501

    @validate_arguments
    def prepare_a_non_fungible_token_transfer_from_address_with_http_info(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"mordor\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, prepare_a_non_fungible_token_transfer_from_address_rb : Optional[PrepareANonFungibleTokenTransferFromAddressRB] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Prepare A Non Fungible Token Transfer From Address  # noqa: E501

        Using this endpoint customers can prepare a non-fungible token transfer from an address with private and public keys. The address doesn’t have to belong to a wallet. The response will include the transaction fee in Wei.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.prepare_a_non_fungible_token_transfer_from_address_with_http_info(blockchain, network, context, prepare_a_non_fungible_token_transfer_from_address_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"mordor\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param prepare_a_non_fungible_token_transfer_from_address_rb:
        :type prepare_a_non_fungible_token_transfer_from_address_rb: PrepareANonFungibleTokenTransferFromAddressRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PrepareANonFungibleTokenTransferFromAddressR, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'blockchain',
            'network',
            'context',
            'prepare_a_non_fungible_token_transfer_from_address_rb'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method prepare_a_non_fungible_token_transfer_from_address" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['blockchain']:
            _path_params['blockchain'] = _params['blockchain']

        if _params['network']:
            _path_params['network'] = _params['network']


        # process the query parameters
        _query_params = []
        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['prepare_a_non_fungible_token_transfer_from_address_rb'] is not None:
            _body_params = _params['prepare_a_non_fungible_token_transfer_from_address_rb']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '201': "PrepareANonFungibleTokenTransferFromAddressR",
            '400': "PrepareANonFungibleTokenTransferFromAddress400Response",
            '401': "PrepareANonFungibleTokenTransferFromAddress401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "PrepareANonFungibleTokenTransferFromAddress403Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }

        return self.api_client.call_api(
            '/blockchain-tools/{blockchain}/{network}/transactions/prepare-nft-from-address', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def prepare_transaction_from_address(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"goerli\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, prepare_transaction_from_address_rb : Optional[PrepareTransactionFromAddressRB] = None, **kwargs) -> PrepareTransactionFromAddressR:  # noqa: E501
        """Prepare Transaction From Address  # noqa: E501

        Through this endpoint customers can prepare a transaction from an address with private and public keys. The address doesn’t have to belong to a wallet.  The response will include the transaction fee in Wei.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.prepare_transaction_from_address(blockchain, network, context, prepare_transaction_from_address_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"goerli\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param prepare_transaction_from_address_rb:
        :type prepare_transaction_from_address_rb: PrepareTransactionFromAddressRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PrepareTransactionFromAddressR
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the prepare_transaction_from_address_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.prepare_transaction_from_address_with_http_info(blockchain, network, context, prepare_transaction_from_address_rb, **kwargs)  # noqa: E501

    @validate_arguments
    def prepare_transaction_from_address_with_http_info(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"goerli\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, prepare_transaction_from_address_rb : Optional[PrepareTransactionFromAddressRB] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Prepare Transaction From Address  # noqa: E501

        Through this endpoint customers can prepare a transaction from an address with private and public keys. The address doesn’t have to belong to a wallet.  The response will include the transaction fee in Wei.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.prepare_transaction_from_address_with_http_info(blockchain, network, context, prepare_transaction_from_address_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"goerli\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param prepare_transaction_from_address_rb:
        :type prepare_transaction_from_address_rb: PrepareTransactionFromAddressRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PrepareTransactionFromAddressR, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'blockchain',
            'network',
            'context',
            'prepare_transaction_from_address_rb'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method prepare_transaction_from_address" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['blockchain']:
            _path_params['blockchain'] = _params['blockchain']

        if _params['network']:
            _path_params['network'] = _params['network']


        # process the query parameters
        _query_params = []
        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['prepare_transaction_from_address_rb'] is not None:
            _body_params = _params['prepare_transaction_from_address_rb']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '201': "PrepareTransactionFromAddressR",
            '400': "PrepareTransactionFromAddress400Response",
            '401': "PrepareTransactionFromAddress401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "PrepareTransactionFromAddress403Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }

        return self.api_client.call_api(
            '/blockchain-data/{blockchain}/{network}/transactions/prepare-from-address', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def validate_address(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, validate_address_rb : Optional[ValidateAddressRB] = None, **kwargs) -> ValidateAddressR:  # noqa: E501
        """Validate Address  # noqa: E501

        This endpoint checks user public addresses whether they are valid or not.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate_address(blockchain, network, context, validate_address_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param validate_address_rb:
        :type validate_address_rb: ValidateAddressRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ValidateAddressR
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the validate_address_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.validate_address_with_http_info(blockchain, network, context, validate_address_rb, **kwargs)  # noqa: E501

    @validate_arguments
    def validate_address_with_http_info(self, blockchain : Annotated[StrictStr, Field(..., description="Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.")], network : Annotated[StrictStr, Field(..., description="Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks.")], context : Annotated[Optional[StrictStr], Field(description="In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.")] = None, validate_address_rb : Optional[ValidateAddressRB] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Validate Address  # noqa: E501

        This endpoint checks user public addresses whether they are valid or not.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate_address_with_http_info(blockchain, network, context, validate_address_rb, async_req=True)
        >>> result = thread.get()

        :param blockchain: Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
        :type blockchain: str
        :param network: Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \"mainnet\" is the live network with actual data while networks like \"testnet\", \"ropsten\" are test networks. (required)
        :type network: str
        :param context: In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. `context` is specified by the user.
        :type context: str
        :param validate_address_rb:
        :type validate_address_rb: ValidateAddressRB
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ValidateAddressR, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'blockchain',
            'network',
            'context',
            'validate_address_rb'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_address" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['blockchain']:
            _path_params['blockchain'] = _params['blockchain']

        if _params['network']:
            _path_params['network'] = _params['network']


        # process the query parameters
        _query_params = []
        if _params.get('context') is not None:  # noqa: E501
            _query_params.append(('context', _params['context']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['validate_address_rb'] is not None:
            _body_params = _params['validate_address_rb']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['ApiKey']  # noqa: E501

        _response_types_map = {
            '200': "ValidateAddressR",
            '400': "ValidateAddress400Response",
            '401': "ValidateAddress401Response",
            '402': "ConvertBitcoinCashAddress402Response",
            '403': "ValidateAddress403Response",
            '409': "ConvertBitcoinCashAddress409Response",
            '415': "ConvertBitcoinCashAddress415Response",
            '422': "ConvertBitcoinCashAddress422Response",
            '429': "ConvertBitcoinCashAddress429Response",
            '500': "ConvertBitcoinCashAddress500Response",
        }

        return self.api_client.call_api(
            '/blockchain-tools/{blockchain}/{network}/addresses/validate', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
